<!DOCTYPE html>
<html lang="en">
<head>
    <link href="https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Orbitron&family=Caudex&family=Audiowide&family= &family=Yrsa&family=Glory&family=Marcellus&family=Titillium+Web&family=Handjet&family=Prompt:ital,wght@0,300;0,400;1,300;1,400&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Anatomy Overview</title>
    <link rel="stylesheet" href="overview.css">
</head>
<div id="intro" style="position:absolute;color:white;margin-top:-49%;text-align: left;font-size:28px;">Choose the one you care the most:</div>
<body>

    <div class="overview-container">
      <div id="glow-field"></div>
        <h1 class="overview-title hidden">About "Digital Anatomy"</h1>
        <div class="overview-subtitle hidden" style="color:ghostwhite;">
            <p class="typing-text">Data Skin is used to protect our data, like human skin.</p>
            <p class="typing-text" style="margin-top: -1%;">Each part of your body holds a different kind of data. Here's how they're mapped:</p>
        </div>
    
    <div class="overview-grid hidden">
        <div class="left info-panel">
          <div class="info-item" data-key="eyes">Eyes – Visual Data<br><span class="info-desc">Photos, camera access</span></div>
          <div class="info-item" data-key="heart">Heart – Personal Info<br><span class="info-desc">Name, contact, profile</span></div>
          <div class="info-item" data-key="skin">Skin – Biometric<br><span class="info-desc">Face, fingerprint</span></div>
        </div>
      
        <div class="body-map">
          <img src="body-outline.png" alt="Human Body Outline" class="body-img body-image-avoid">
          <div class="dot brain" data-key="brain"></div>
          <div class="dot eyes" data-key="eyes"></div>
          <div class="dot ears" data-key="ears"></div>
          <div class="dot heart" data-key="heart"></div>
          <div class="dot feet" data-key="feet"></div>
          <div class="dot hands" data-key="hands"></div>
          <div class="dot skin" data-key="skin"></div>
        </div>
      
        <div class="right info-panel">
          <div class="info-item" data-key="brain">Brain – Cognitive Data<br><span class="info-desc">Preferences, habits</span></div>
          <div class="info-item" data-key="ears">Ears – Audio Data<br><span class="info-desc">Voice recordings</span></div>
          <div class="info-item" data-key="hands">Hands – Communication<br><span class="info-desc">Messages, chat logs</span></div>
          <div class="info-item" data-key="feet">Feet – Location<br><span class="info-desc">Where you've been</span></div>
        </div>

        <button class="scan-btn" onclick="location.href='personal-tests/personal-test.html'">Understood</button>
  </div>
  
  <script>
// Global BGM variable
let bgm;

document.addEventListener('DOMContentLoaded', async function() {
    // Check if BGM should be playing from previous page
    const shouldPlayBGM = sessionStorage.getItem('bgmPlaying') === 'true';
    const bgmPosition = parseFloat(sessionStorage.getItem('bgmPosition') || '0');
    
    if (shouldPlayBGM) {
        bgm = new Audio('sound/bgm1.mp3');
        bgm.loop = true;
        bgm.volume = 0.5;
        
        // Set the current time to resume from the previous position
        bgm.addEventListener('loadedmetadata', function() {
            bgm.currentTime = bgmPosition;
            bgm.play().catch(err => {
                console.log("Auto-play prevented, adding click handler");
                
                // One-time click handler to start BGM
                const playBGM = function() {
                    bgm.play();
                    document.removeEventListener('click', playBGM);
                };
                document.addEventListener('click', playBGM);
            });
        });
    }

    // Modified typing effect for overview page
    async function typeText(element, text) {
        const originalText = text;  // Store the original text
        element.textContent = '';   // Clear the element
        
        // Play typing sound once for the whole sentence
        const typingSound = new Audio('sound/typing.mp3');
        typingSound.volume = 0.4;
        typingSound.play();
        
        // Type each character
        for (let i = 0; i < originalText.length; i++) {
            element.textContent += originalText.charAt(i);  // Add each character
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        // Stop sound when sentence is complete
        typingSound.pause();
        typingSound.currentTime = 0;
    }

    const title = document.querySelector('.overview-title');
    const subtitle = document.querySelector('.overview-subtitle');
    const grid = document.querySelector('.overview-grid');
    const typingTexts = document.querySelectorAll('.typing-text');
    
    const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
    
    async function startAnimationSequence() {
        title.classList.remove('hidden');
        title.classList.add('fade-in');
        
        await wait(1000);
        
        subtitle.classList.remove('hidden');
        subtitle.classList.add('fade-in');
        
        for (let i = 0; i < typingTexts.length; i++) {
            const text = typingTexts[i];
            const originalText = text.textContent;  // Store original text before clearing
            text.classList.add('visible');
            await typeText(text, originalText);     // Pass the original text
            await wait(800);
        }
        
        await wait(500);
        grid.classList.remove('hidden');
        grid.classList.add('fade-in');
    }
    
    startAnimationSequence();

    // Update the scan button click handler
    document.querySelector('.scan-btn').addEventListener('click', () => {
        if (bgm) {
            bgm.pause();
            bgm.currentTime = 0;
            sessionStorage.removeItem('bgmPlaying');
            sessionStorage.removeItem('bgmPosition');
        }
    });
});

const glowField = document.getElementById("glow-field");
const GLOW_COUNT = 8;
const existingPositions = [];
const bodyImage = document.querySelector('.body-image-avoid');
const bodyRect = bodyImage.getBoundingClientRect();

function distance(x1, y1, x2, y2) {
  const dx = x1 - x2;
  const dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

for (let i = 0; i < GLOW_COUNT; i++) {
  let attempts = 0;
  let top, left;
  let tooClose = false;

  do {
    tooClose = false;
    top = Math.random() * 90;
    left = Math.random() * 90;
    attempts++;

    // 暂时生成一个虚拟 DOM 空间来判断位置
    const container = glowField.getBoundingClientRect();
    const xPx = container.left + (left / 100) * container.width;
    const yPx = container.top + (top / 100) * container.height;

    // 如果粒子中心点落在人体 image 区域里，就重新生成
    if (
      xPx > bodyRect.left &&
      xPx < bodyRect.right &&
      yPx > bodyRect.top &&
      yPx < bodyRect.bottom
    ) {
      tooClose = true;
      continue;
    }

    for (const pos of existingPositions) {
      if (distance(left, top, pos.left, pos.top) < 35) {
        tooClose = true;
        break;
      }
    }
  } while (tooClose && attempts < 30);

  existingPositions.push({ top, left });

  const glow = document.createElement("div");
  glow.classList.add("pulse-glow");
  glow.style.top = `${top}%`;
  glow.style.left = `${left}%`;

  const size = 100 + Math.random() * 100;
  glow.style.width = glow.style.height = `${size}px`;
  glow.style.animationDuration = `${35 + Math.random() * 15}s`;
  glow.style.animationDelay = `${Math.random() * 10}s`;

  glowField.appendChild(glow);
}

const dots = document.querySelectorAll('.dot');
const panels = document.querySelectorAll('.info-item');
const dotSequence = ['brain', 'eyes', 'ears', 'heart', 'skin', 'hands', 'feet'];
let currentDotIndex = 0;

// Initially hide all info panels and make all dots grey except the first one
panels.forEach(panel => {
    panel.style.cssText = `
        opacity: 0;
        visibility: hidden;
        transform: translateY(20px);
        transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
    `;
});

// Style for inactive dots
dots.forEach(dot => {
    if (dot.getAttribute('data-key') !== dotSequence[0]) {
        dot.style.cssText = `
            background: #808080;
            opacity: 0.7;
        `;
        // Change the before pseudo-element color for inactive dots
        dot.style.setProperty('--pulse-color', 'rgba(255, 255, 255, 0.2)');
    }
});

let currentlyShownPanel = null;

// Update the dots click event handler
dots.forEach(dot => {
    dot.addEventListener('click', () => {
        const key = dot.getAttribute('data-key');
        
        // Only proceed if this is the current dot in sequence
        if (key === dotSequence[currentDotIndex]) {
            // Remove active-line class from all dots first
            dots.forEach(d => {
                d.classList.remove('active-line');
            });
            
            // Add active-line class to the clicked dot
            dot.classList.add('active-line');
            
            // Hide currently shown panel if it exists
            if (currentlyShownPanel) {
                currentlyShownPanel.style.opacity = '0';
                currentlyShownPanel.style.visibility = 'hidden';
                currentlyShownPanel.style.transform = 'translateY(20px)';
                currentlyShownPanel = null;
            }

            // Show the clicked panel
            panels.forEach(panel => {
                if (panel.getAttribute('data-key') === key) {
                    panel.style.opacity = '1';
                    panel.style.visibility = 'visible';
                    panel.style.transform = 'translateY(0)';
                    currentlyShownPanel = panel;
                }
            });

            // Play ping sound
            const clickSound = new Audio('sound/ping.mp3');
            clickSound.volume = 0.3;
            clickSound.play();

            // Check if this was the last dot (feet)
            if (key === 'feet') {
                // Reveal all panels with staggered animation
                setTimeout(() => {
                    // Remove all active-line classes first
                    dots.forEach(d => {
                        d.classList.remove('active-line');  // Remove any existing line
                    });
                    
                    // Make all dots active but WITHOUT showing their lines
                    dots.forEach(d => {
                        d.style.cssText = `
                            background: #00f9ff;
                            opacity: 1;
                            transition: all 2s ease;
                        `;
                        d.style.setProperty('--pulse-color', 'rgba(0, 249, 255, 0.3)');
                        // Don't add the active-line class here
                    });
                    
                    // Show all panels with staggered animation
                    panels.forEach((panel, index) => {
                        setTimeout(() => {
                            panel.style.cssText = `
                                opacity: 1;
                                visibility: visible;
                                transform: translateY(0);
                                transition: all 2s cubic-bezier(0.25, 0.1, 0.25, 1.0);
                            `;
                        }, index * 200);
                    });
                    
                    // Play a special reveal sound
                    const revealSound = new Audio('sound/ping.mp3');
                    revealSound.volume = 0.4;
                    revealSound.play();
                }, 1000);
            } else {
                // Not the last dot, continue with sequence
                currentDotIndex++;

                // Update dot colors
                dots.forEach(d => {
                    const dotKey = d.getAttribute('data-key');
                    if (dotKey === dotSequence[currentDotIndex]) {
                        // Next active dot
                        d.style.cssText = `
                            background: #00f9ff;
                            opacity: 1;
                        `;
                        d.style.setProperty('--pulse-color', 'rgba(0, 249, 255, 0.2)');
                    } else if (currentDotIndex > dotSequence.indexOf(dotKey)) {
                        // Previously clicked dots - just lower opacity
                        d.style.cssText = `
                            background: #00f9ff;
                            opacity: 0.5;
                        `;
                        d.style.setProperty('--pulse-color', 'rgba(0, 249, 255, 0.2)');
                    } else if (currentDotIndex < dotSequence.indexOf(dotKey)) {
                        // Not yet active dots - grey with white pulse
                        d.style.cssText = `
                            background: #808080;
                            opacity: 0.7;
                        `;
                        d.style.setProperty('--pulse-color', 'rgba(255, 255, 255, 0.2)');
                    }
                });
            }
        }
    });
});
  </script>
  
</body>
</html>
